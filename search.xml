<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown学习</title>
    <url>/2022/03/08/Markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><ol>
<li><p>段落换行</p>
<p>两段中间空一行  </p>
<p>两端中间空一行<br>（为什么看起来没变化？）</p>
</li>
</ol>
<p><br><br></p>
<ol start="2">
<li><p>字体<br> <em>斜体文本</em>   *斜体文本*<br> <em>斜体文本</em>   _斜体文本_<br> <strong>粗体文本</strong>    **粗体文本**<br> <strong>粗体文本</strong>    __粗体文本__<br> <em><strong>粗斜体文本</strong></em>    ***粗斜体文本***<br> <em><strong>粗斜体文本</strong></em>    ___粗斜体文本___<br><br><br></p>
</li>
<li><p>分割线<br>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。<br>(***)<br>(* * *)<br>(—)<br>(___)<br><br><br></p>
</li>
<li><p>删除线<br>两边各加~~<br><del>两边各加</del><br><br><br></p>
</li>
<li><p>下划线<br><u>下划线</u><br>&lt;u&gt;下划线&lt;&#x2F;u&gt;<br><br><br></p>
</li>
<li><p>脚注<br>创建脚注：[^要注明的文本]</p>
<p>脚注[^歪比歪比]<br>[^歪比歪比]: 所以是个脚注</p>
</li>
</ol>
<p><br><br></p>
<ol start="7">
<li><p>列表</p>
<ol>
<li>无序列表:<br>  使用*空格，+空格，-空格。<ul>
<li>1</li>
</ul>
<ul>
<li>2</li>
</ul>
<ul>
<li>3</li>
</ul>
</li>
<li>有序列表:<br>  1.空格<br>  2.空格<br>  3.空格</li>
<li>列表嵌套:<ol>
<li>第一项:<ul>
<li>s</li>
<li>a</li>
</ul>
</li>
<li>第二项:<ul>
<li>s</li>
<li>a<br><br><br></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>区块:<br>&amp;emsp; Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>
<blockquote>
<p>q<br>w</p>
</blockquote>
<blockquote>
<p>e<br>r</p>
</blockquote>
<p>&amp;emsp;区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</p>
<blockquote>
<p>这是最外层</p>
<blockquote>
<p>这是第一层<br>   还是第一层</p>
</blockquote>
</blockquote>
</li>
</ol>
<p><br><br></p>
<ol start="9">
<li><p>代码:<br> &amp;emsp;如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`）<br> <code>int i = 1</code>     `int i &#x3D; 1`<br><br><br></p>
<ol>
<li>代码区块：<br> 用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定） <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">cout &lt; &lt; i &lt; &lt; endl;</span><br></pre></td></tr></table></figure>
 `&#96;&#96;c++<br> int i &#x3D; 1;<br> cout &lt; &lt; i &lt; &lt; endl;<br> `&#96;&#96;</li>
</ol>
</li>
</ol>
<p><br><br></p>
<ol start="10">
<li><p>链接：<br>[链接名称](链接地址)<br>或者<br>&lt;链接地址&gt;</p>
<p><a href="https://www.runoob.com/">菜鸟教程</a><br><a href="https://www.runoob.com/">https://www.runoob.com</a></p>
</li>
</ol>
<p><br><br></p>
<ol start="11">
<li><p>图片：<br><img src="http://r91oo274o.hd-bkt.clouddn.com/test.png" alt="tom" title="tom"></p>
<center>急</center>

<p></p>

<img src="http://static.runoob.com/images/runoob-logo.png">

<img src="http://r91oo274o.hd-bkt.clouddn.com/test.png">

<p>![alt 属性文本](文件夹下的图片 “可选标题”)<br>![alt 属性文本](图片链接 “可选标题”)<br><br><br></p>
<p>&lt;img src&#x3D;”url” width&#x3D;”400” height&#x3D;”400” alt&#x3D;”” title&#x3D;”” style&#x3D;”zoom:50%;”&#x2F;&gt;<br>其中，src：该图片的网址<br>alt：是图片没有加载成功时，显示的文字<br>title：该图片的标题<br>style：设置缩放</p>
<p><br><br><br>表格和其他应该用不上，暂时不写</p>
</li>
</ol>
<h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h6 id="最高六级标题"><a href="#最高六级标题" class="headerlink" title="最高六级标题"></a>最高六级标题</h6>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>算法与数据结构(2)</title>
    <url>/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</url>
    <content><![CDATA[<p>顺序表多少有点摆烂，看看书吧。</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><ol>
<li>定义：<br>  由n(n&gt;&#x3D;0)个数据元素（结点）a<del>1</del>,a<del>2</del>,a<del>3</del>,…a<del>n</del>组成的有限序列。<ul>
<li>数据元素的个数n定义为表的长度。</li>
<li>n&#x3D;0时称为空表。</li>
<li>将非空的线性表（n&gt;0）记作：(a<del>1</del>,a<del>2</del>,a<del>3</del>,…a<del>n</del>)</li>
<li>这里的数据元素a<del>i</del>（1&lt;&#x3D;i&lt;&#x3D;n)只是一个抽象的符号，其具体含义在不同情况下可以不同</li>
<li>同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系。</li>
</ul>
</li>
<li>逻辑特征：<br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-22-17-22-47.png">  </li>
<li>类型定义：<br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-22-18-42-57.png"></li>
</ol>
<h3 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h3><ul>
<li>顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。（逻辑上相邻，物理上也相邻）</li>
<li>线性表存储结构占用一片连续的存储空间。</li>
<li>在访问线性表时，可以快速计算出任何一个数据元素的存储地址。因此可以粗略认为，访问每个元素花费时间相等。是<strong>随机存取法</strong>。 </li>
<li>线性表基本操作：<br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-00-41-35.png"></li>
<li>顺序表优缺点：<ol>
<li>优点：<ul>
<li>存储密度大</li>
<li>可以随机存取表中任一元素</li>
</ul>
</li>
<li>缺点：<ul>
<li>在插入、删除某一元素时，需要移动大量元素   </li>
<li>浪费存储空间</li>
<li>属于静态存储形式，数据元素的个数不能自由扩充</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h3><ul>
<li><p>链式存储定义：用一组物理位置任意的存储单元来存放线性表的数据元素</p>
</li>
<li><p>这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。</p>
</li>
<li><p>链表特点：</p>
<ul>
<li>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。</li>
<li>访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等。是<strong>顺序存取法</strong>。</li>
</ul>
</li>
<li><p>链式存储结构术语：</p>
<ul>
<li><p>结点：数据元素的存储映像。由数据域和指针域组成。</p>
<ul>
<li>各结点由两个域组成：<ul>
<li>数据域：存储元素数值数据</li>
<li>指针域：存储后继结点的存储位置</li>
</ul>
</li>
</ul>
</li>
<li><p>链表：n个结点由指针链组成一个链表</p>
<ul>
<li>单链表、双链表和循环链表：<ul>
<li>结点只有一个指针域的链表，称为<strong>单链表</strong>或线性链表<br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-15-53-33.png"></li>
<li>结点有两个指针域的链表，称为<strong>双链表</strong><br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-15-54-32.png"> </li>
<li>首尾相接的链表称为<strong>循环链表</strong><br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-15-55-37.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>头指针、头结点和首元结点：</p>
<ul>
<li>头指针：指向链表中第一个结点的指针</li>
<li>首元结点：链表中存储第一个数据元素的结点</li>
<li>头结点：在链表的首元结点之前附设的一个结点<br> <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-15-58-21.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>关于链表的一些讨论：</p>
<ul>
<li>如何表示空表？<ul>
<li>无头结点时，头指针为空时表示空表</li>
<li>有头结点时，当头结点的指针域为空时表示空表</li>
</ul>
</li>
<li>设置头结点有什么好处？<ol>
<li>便于首元结点的处理<ul>
<li>首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理</li>
</ul>
</li>
<li>便于空表和非空表的统一处理<ul>
<li>无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。</li>
</ul>
</li>
</ol>
</li>
<li>头结点的数据域中装的是什么？<ul>
<li>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-16-12-17.png"></p>
<ul>
<li>单链表由头指针唯一确定，因此单链表可以用头指针的名字来命名。若头指针名是L，则把链表称为表L。</li>
</ul>
<p><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-16-16-06.png"></p>
<p>这里 next 包含了下一个结点</p>
<ul>
<li><p>通常，<br>   定义链表L：LinkList L；<br>   定义结点指针p：LNode *p；<br>   虽然说LinkList和LNode是等价的。</p>
</li>
<li><p>为了统一链表的操作，通常这样定义链表：</p>
</li>
</ul>
<p><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-16-22-34.png"></p>
<center>存储学生学号姓名成绩的单链表节点类型定义</center>

<ul>
<li>单链表基本操作：<br><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-20-57-10.png"><br>（操作的算法还是自己多动手去吧。）</li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>算法与数据结构(1)</title>
    <url>/2022/03/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>写在前面：因为之前就学了数据结构的内容，所以这篇数据结构就偷懒跳过不写了</p>
<h1 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h1><ol>
<li><p>定义：<br>对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。<br>简而言之，<strong>算法就是解决问题的方法和步骤</strong></p>
</li>
<li><p>算法特性：</p>
<ol>
<li>有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。</li>
<li>确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。 </li>
<li>可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</li>
<li>输入：一个算法有0个或多个输入。</li>
<li>输出：一个算法有一个或多个输出。</li>
</ol>
</li>
<li><p>算法设计要求：</p>
<ol>
<li>正确性：程序对于精心选择的，典型、苛刻且带有刁难性的几组输入数据能够得出满足要求的结果。</li>
<li>可读性</li>
<li>健壮性：<ol>
<li>指输入非法数据时，算法恰当的做出反应或进行相应处理而不是产生奇怪的输出结果。</li>
<li>处理出错的方法，不应是中断程序的执行，而是返回一个表示错误或者错误性质的值，以便在更高的抽象层次上进行处理。</li>
</ol>
</li>
<li>高效性</li>
</ol>
</li>
<li><p>算法的效率：</p>
<ul>
<li>算法有时间效率和空间效率</li>
</ul>
<ol>
<li>时间效率：<br> 时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量<ul>
<li>度量方法：<ol>
<li>事后统计：<br>  将算法实现，测算时间和空间开销。</li>
<li>事前分析：<br>  对算法所消耗资源的一种估算方法。</li>
</ol>
<ul>
<li>多采用事前分析，事后统计的方法，编写程序耗费时间和精力，结果依赖于计算机软硬件因素。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>算法运行时间 &#x3D; 一个简单操作所需时间 $\times$ 简单操作次数<br>        &#x3D; $\sum$ 每条语句执行次数（每条语句频度） $\times$ 该语句执行一次所需时间<ul>
<li>假设执行每条语句所需时间均为单位时间，此时对算法的运行时间的讨论就可以转化为讨论该算法中的所有语句的执行次数，即频度和。</li>
<li>即算法耗费时间为算法每条语句的频度之和，表示为T(n)。</li>
<li>额外的，一般只考虑算法中的基本操作执行的次数，且仅比较数量级</li>
</ul>
</li>
<li>算法时间复杂度：<ul>
<li>算法中基本语句（执行最多的语句）重复执行的次数是问题规模n的某个函数f(n)，算法时间的量度记作T(n) &#x3D; O(f(n))</li>
<li>它表示随着n增大，算法执行的时间的增长率和f(n)的增长率相同，称为渐近时间复杂度。</li>
<li>对于复杂的算法，可以将它分为几个容易估算的部分，然后利用加法法则和乘法法则计算时间复杂度<ol>
<li>加法法则：<br> T(n) &#x3D; T1(n) + T2(n) &#x3D; O(f(n)) + O(g(n)) &#x3D;O(max(f(n),g(n)))</li>
<li>乘法法则：<br> T(n) &#x3D; T1(n) $\times$ T2(n) &#x3D; O(f(n)) $\times$ O(g(n)) &#x3D; O(f(n) $\times$ g(n))</li>
</ol>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>算法空间复杂度：<br> S(n) &#x3D; O(f(n))<ul>
<li>算法要占据的空间：<ol>
<li>算法本身要占据的空间，输入&#x2F;输出，指令，常数，变量等</li>
<li>算法要使用的辅助空间</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>计算时间复杂度的练习</title>
    <url>/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/2022-03-21-23-07-37.png"></p>
<ol>
<li>很容易看出语句频度最大的语句是<code>for(int j = 0;j &lt; n;j++)</code></li>
<li>其执行次数为n(n+1),即n^2^<ul>
<li>对于循环来说直接找嵌套最深的语句也可以，即<code>y++;</code>,执行次数为n^2^</li>
</ul>
</li>
<li>T(n)&#x3D;O(n^2^)</li>
</ol>
<p>####例1</p>
<p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/2022-03-21-23-17-41.png" title="例1"></p>
<ol>
<li>嵌套最深的语句为<code>sum[i] += x[i][j];</code> </li>
<li>执行次数为 m $\times$ n 次</li>
<li>T(n)&#x3D;O(m $\times$ n)</li>
</ol>
<p>####虽然但是这是例2<br><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/2022-03-21-23-21-45.png"></p>
<ol>
<li>嵌套最深语句为<code>c[i][j] = c[i][j] + a[i][k] * b[k][j];</code></li>
<li>执行次数为n^3^</li>
<li>T(n)&#x3D;O(n^3^)</li>
</ol>
<p>####例3</p>
<p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/2022-03-21-23-26-30.png"></p>
<ol>
<li>可以看出嵌套最深语句是<code>x=x+1</code> </li>
<li>但是计算时间复杂度时，需要用级数求和法</li>
<li>语句频度 &#x3D; $\sum_{i&#x3D;1}^n$$\sum_{j&#x3D;1}^i$$\sum_{k&#x3D;1}^j$1 &#x3D; $\sum_{i&#x3D;1}^n$$\sum_{j&#x3D;1}^i$j &#x3D; $\sum_{i&#x3D;1}^n$$i(i+1) \over 2$ &#x3D;$1\over2$($\sum_{i&#x3D;1}^n$i^2^ + $\sum_{i&#x3D;1}^n$i) &#x3D;$1\over2$($n(n+1)(2n+1)\over 6$ + $n(n+1)\over2$) &#x3D; $n(n+1)(n+2)\over 6$</li>
<li>f(n) &#x3D; n^3^</li>
<li>T(n)&#x3D;O(n^3^)<ul>
<li>（计算语句频度最后一个求和不会。。）</li>
</ul>
</li>
</ol>
<p>####例4</p>
<p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/2022-03-22-00-05-42.png"></p>
<ol>
<li><p>执行次数最多为<code>i=i*2;</code></p>
<ul>
<li>关键要找出执行次数x与n的关系，并表示成n的函数</li>
<li>执行1次，i&#x3D;1*2&#x3D;2；</li>
<li>执行2次，i&#x3D;2*2&#x3D;2^2^；</li>
<li>执行3次，i&#x3D;2^2^*2&#x3D;2^3^；</li>
<li>…</li>
<li>执行x次，i&#x3D;2^x^</li>
</ul>
</li>
<li><p>设语句<code>i=i*2</code>执行x次,由循环条件，</p>
<p> i&lt;&#x3D;n,   $\because$ 2^x^&lt; n , $\therefore$ x&lt;&#x3D;${log_2{n}}$</p>
</li>
<li><p>所以f(n)&#x3D;${log_2{n}}$</p>
</li>
<li><p>T(n)&#x3D;O(${log_2{n}}$)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
</search>
