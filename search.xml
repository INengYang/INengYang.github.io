<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>4.3Python</title>
    <url>/2022/04/03/4-3Python/</url>
    <content><![CDATA[<h4 id="Python输入列表"><a href="#Python输入列表" class="headerlink" title="Python输入列表"></a>Python输入列表</h4><ol>
<li><p>split()</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = <span class="built_in">input</span>(<span class="string">&quot;输入：&quot;</span>).split()</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure>
<p> 输出：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>map()</p>
<p> map()会根据提供的函数对指定序列做映射。<br> map(function, iterable, …)</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">input</span>(<span class="string">&quot;输入：&quot;</span>).split()</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,s))</span><br></pre></td></tr></table></figure>

<p> 运行</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x0000022C58D8B4F0</span>&gt;</span><br></pre></td></tr></table></figure>
<p> python3 中 map返回值不是列表而是iterators，可以用用list方法转换成列表  </p>
<p> 这样似乎更方便</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>(<span class="string">&quot;输入用空格分隔的数字：&quot;</span>).split())) </span><br></pre></td></tr></table></figure></li>
</ol>
<p>关于map()，更多还是去看教程吧。</p>
<h4 id="input输入多个数"><a href="#input输入多个数" class="headerlink" title="input输入多个数"></a>input输入多个数</h4><p>还是map()和split()<br>a, b, c &#x3D; map(int, input().split())</p>
<h4 id="获取列表下标"><a href="#获取列表下标" class="headerlink" title="获取列表下标"></a>获取列表下标</h4><ul>
<li><p>列表.index()</p>
<p>  如：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target_list = [<span class="number">35</span>, <span class="number">67</span>, <span class="number">6</span>, <span class="number">77</span>, <span class="number">89</span>, <span class="number">98</span>]</span><br><span class="line"><span class="built_in">print</span>(target_list.index(<span class="number">89</span>))</span><br></pre></td></tr></table></figure>
<p>  运行：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>  不过当时是为了查找元素对应的下标，可以这么写：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> target_list:</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">89</span>:</span><br><span class="line">    <span class="comment">#输出89的下标</span></span><br><span class="line">    <span class="built_in">print</span>(target_list.index(i))</span><br><span class="line">    <span class="comment">#将89改为88</span></span><br><span class="line">    target_list[target_list.index(i)] = <span class="number">88</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>有用的知识</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/2022/03/08/Markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><ol>
<li><p>段落换行</p>
<p>两段中间空一行  </p>
<p>两端中间空一行<br>（为什么看起来没变化？）</p>
</li>
</ol>
<p><br><br></p>
<ol start="2">
<li><p>字体<br> <em>斜体文本</em>   *斜体文本*<br> <em>斜体文本</em>   _斜体文本_<br> <strong>粗体文本</strong>    **粗体文本**<br> <strong>粗体文本</strong>    __粗体文本__<br> <em><strong>粗斜体文本</strong></em>    ***粗斜体文本***<br> <em><strong>粗斜体文本</strong></em>    ___粗斜体文本___<br><br><br></p>
</li>
<li><p>分割线<br>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。<br>(***)<br>(* * *)<br>(—)<br>(___)<br><br><br></p>
</li>
<li><p>删除线<br>两边各加~~<br><del>两边各加</del><br><br><br></p>
</li>
<li><p>下划线<br><u>下划线</u><br>&lt;u&gt;下划线&lt;&#x2F;u&gt;<br><br><br></p>
</li>
<li><p>脚注<br>创建脚注：[^要注明的文本]</p>
<p>脚注[^歪比歪比]<br>[^歪比歪比]: 所以是个脚注</p>
</li>
</ol>
<p><br><br></p>
<ol start="7">
<li><p>列表</p>
<ol>
<li>无序列表:<br>  使用*空格，+空格，-空格。<ul>
<li>1</li>
</ul>
<ul>
<li>2</li>
</ul>
<ul>
<li>3</li>
</ul>
</li>
<li>有序列表:<br>  1.空格<br>  2.空格<br>  3.空格</li>
<li>列表嵌套:<ol>
<li>第一项:<ul>
<li>s</li>
<li>a</li>
</ul>
</li>
<li>第二项:<ul>
<li>s</li>
<li>a<br><br><br></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>区块:<br>&amp;emsp; Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>
<blockquote>
<p>q<br>w</p>
</blockquote>
<blockquote>
<p>e<br>r</p>
</blockquote>
<p>&amp;emsp;区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</p>
<blockquote>
<p>这是最外层</p>
<blockquote>
<p>这是第一层<br>   还是第一层</p>
</blockquote>
</blockquote>
</li>
</ol>
<p><br><br></p>
<ol start="9">
<li><p>代码:<br> &amp;emsp;如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`）<br> <code>int i = 1</code>     `int i &#x3D; 1`<br><br><br></p>
<ol>
<li>代码区块：<br> 用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定） <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">cout &lt; &lt; i &lt; &lt; endl;</span><br></pre></td></tr></table></figure>
 `&#96;&#96;c++<br> int i &#x3D; 1;<br> cout &lt; &lt; i &lt; &lt; endl;<br> `&#96;&#96;</li>
</ol>
</li>
</ol>
<p><br><br></p>
<ol start="10">
<li><p>链接：<br>[链接名称](链接地址)<br>或者<br>&lt;链接地址&gt;</p>
<p><a href="https://www.runoob.com/">菜鸟教程</a><br><a href="https://www.runoob.com/">https://www.runoob.com</a></p>
</li>
</ol>
<p><br><br></p>
<ol start="11">
<li><p>图片：<br><img src="http://r91oo274o.hd-bkt.clouddn.com/test.png" alt="tom" title="tom"></p>
<center>急</center>

<p></p>

<img src="http://static.runoob.com/images/runoob-logo.png">

<img src="http://r91oo274o.hd-bkt.clouddn.com/test.png">

<p>![alt 属性文本](文件夹下的图片 “可选标题”)<br>![alt 属性文本](图片链接 “可选标题”)<br><br><br></p>
<p>&lt;img src&#x3D;”url” width&#x3D;”400” height&#x3D;”400” alt&#x3D;”” title&#x3D;”” style&#x3D;”zoom:50%;”&#x2F;&gt;<br>其中，src：该图片的网址<br>alt：是图片没有加载成功时，显示的文字<br>title：该图片的标题<br>style：设置缩放</p>
<p><br><br><br>表格和其他应该用不上，暂时不写</p>
</li>
</ol>
<h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h6 id="最高六级标题"><a href="#最高六级标题" class="headerlink" title="最高六级标题"></a>最高六级标题</h6>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>First-plan</title>
    <url>/2022/04/08/First-plan/</url>
    <content><![CDATA[<p>简单地列一下目前要做的事情。</p>
<ol>
<li>算法与数据结构学习</li>
<li>python学习，主要是数据开发与爬虫相关的内容</li>
<li>英语学习，目前是六级听力和词汇</li>
<li>看书和平时的锻炼</li>
<li>c++ 这个，暂时先列出来吧</li>
</ol>
<p>目测解封还需要一个月左右，所以大胆地写一下一个月后要达到的目标</p>
<ol>
<li>熟练掌握算法与数据结构的内容，能做到老师布置的作业自主完成</li>
<li>可以自主写代码爬取一些内容并进行数据分析</li>
<li>词汇量增长至少1000词，听力感觉有点玄学，到时做六级真题验收吧</li>
<li>看完传习录；锻炼这个也没法准确设置一个目标，至少做到一周四练，根据具体情况随时调整</li>
<li>c++主要是看c++ primer，计划开始实行后看情况吧。</li>
</ol>
<p>另外还有刷编程题的计划，但之后进行补充。</p>
<p>具体到每天每周的实行，这有点难想，目前有个不成熟的想法：</p>
<ol>
<li><p>首先要早睡早起，这大概是最困难的。最迟8点就该起床。</p>
</li>
<li><p>起床后首先是英语的学习，背单词和听力</p>
</li>
<li><p>顺利的话大概在十点左右结束英语，此时要上课（不过下周与下下周可以不太关心这个），根据上课情况来规划之后干什么</p>
<ol>
<li>如果说没课或者不太重要的课，学python</li>
<li>反之，上课</li>
<li>但是星期三的话就写算法与数据结构作业</li>
</ol>
</li>
<li><p>午饭之后感觉会累，所以先这么安排：看书-&gt;锻炼-&gt;算法与数据结构学习</p>
</li>
<li><p>晚上就根据每天的情况来安排。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>end=&#39;&#39;与--i</title>
    <url>/2022/03/28/end-%E4%B8%8E-i/</url>
    <content><![CDATA[<h3 id="end-x3D-’’"><a href="#end-x3D-’’" class="headerlink" title="end&#x3D;’’"></a>end&#x3D;’’</h3><blockquote>
<p>Python</p>
</blockquote>
<ul>
<li>原理解释：为末尾end传递一个空字符串，这样print函数不会在字符串末尾添加一个换行符，而是添加一个空字符串，其实这也是一个语法要求，表示这个语句没结束。</li>
</ul>
<p>print默认是打印一行，结尾加换行。</p>
<p>原文链接：<a href="https://blog.csdn.net/qq_40318284/article/details/96835229">https://blog.csdn.net/qq_40318284/article/details/96835229</a></p>
<p>在打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    *</span><br><span class="line">   ***</span><br><span class="line">  *****</span><br><span class="line"> *******</span><br><span class="line">*********</span><br></pre></td></tr></table></figure>
<p>时遇到的问题</p>
<p>当时想的是怎么能让空格和*在同一行上打印出来，然后看到了例子的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">row = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入行数: &#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row - i - <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * i + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>就去查了end&#x3D;’’的用法。</p>
<p>自己写的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入打印行数：&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (n - i),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * (<span class="number">2</span> * i -<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="–-i与i-–"><a href="#–-i与i-–" class="headerlink" title="–(++)i与i(++)–"></a>–(++)i与i(++)–</h3><p>–i 是先执行i&#x3D;i-1,然后再使用i的值, 这时的i值就是表达式–i的值。i– 是先使用i的值作为表达式i–的值,然后,执行i&#x3D;i-1操作。<br>++i和i++同理。</p>
]]></content>
      <categories>
        <category>有用的知识</category>
      </categories>
  </entry>
  <entry>
    <title>python3.6安装pycrypto</title>
    <url>/2022/04/22/python3-6%E5%AE%89%E8%A3%85pycrypto/</url>
    <content><![CDATA[<p>在学习爬取网易云评论时需要用到pycrypto，但是python3.6似乎直接pip下载会有点困难，查了很多之后终于解决了。</p>
<p>查到的切实有效的办法是这个<a href="https://blog.csdn.net/wg5foc08/article/details/100286913">链接</a>, 值得一提的是，顺带还学到了想找到vs的安装位置，直接桌面右键-&gt;打开文件所在位置就好。。</p>
<p>ps:<br>在这之前还更新了pip：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>
<p>但是这样报错了，所以使用下面的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m ensurepip</span><br><span class="line"></span><br><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>

<p>安装完成之后（此时文件夹已经存在），发现还是不能使用，所以继续搜索，尝试了这个<a href="https://blog.csdn.net/wdschn/article/details/80806613?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165061776616780271964810%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165061776616780271964810&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80806613.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=python3.6%E5%AE%89%E8%A3%85crypto&spm=1018.2226.3001.4187">链接</a>中的办法,但很遗憾，没有效果。</p>
<p>然后尝试下载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pycryptodemo</span><br></pre></td></tr></table></figure>
<p>仍然木大。。<br>还尝试改变首字母大小写什么的，当然也是没有作用。</p>
<p>但经一篇文章启发，我本地是有python的，而pycharm项目中会自己生成自己的python3.6（大概是这个意思），pycharm又在用anaconda，所以去对比了一下两边的库，发现anaconda中是没有Crypto这个文件夹的（同时自己的python中是有的。。），最后复制一份到pycharm的库中就好了。<br>（不过用到现在还不知道anaconda到底是啥，令人感叹。）</p>
<p>本以为就此可以结束了，但又报错了，这次是“cannot import name ‘_AES’”，原因，简而言之就是计算机是64位的，但pip下载的pycrypto是32位的。<br>通过这篇<a href="https://blog.csdn.net/ychgyyn/article/details/88621236?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165062321216781683948872%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165062321216781683948872&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88621236.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=cannot+import+name+_AES&spm=1018.2226.3001.4187">文章</a>解决了。</p>
]]></content>
      <categories>
        <category>有用的知识</category>
      </categories>
  </entry>
  <entry>
    <title>python列表字符串转换</title>
    <url>/2022/03/31/python%E5%88%97%E8%A1%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="列表转字符串"><a href="#列表转字符串" class="headerlink" title="列表转字符串"></a>列表转字符串</h4><ol>
<li><p>将列表转换为字符串的最基本用法和实现之一是使用join函数将字符串列表转换。 请记住，此方法只能使用仅包含字符串的列表。’ ‘之间是分隔符，如我们所见，每个元素在新字符串中都用单个空格分隔。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>] </span><br><span class="line"><span class="string">&#x27; &#x27;</span>.join(mylist) </span><br><span class="line"><span class="comment">#&#x27;a b c&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如前所述，我们可以转换仅包含字符串元素的列表。 但是，如果我们需要转换包含不同类型数据的列表，该怎么办？ 我们需要一些转换为字符串。 我们将使用str函数将不同的数据类型转换为字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]      </span><br><span class="line"><span class="string">&#x27; &#x27;</span>.join(<span class="built_in">str</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> mylist)        </span><br><span class="line"><span class="comment">#&#x27;1 2 3&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>在写一个去除字符串中的空格时用到的，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trim</span>(<span class="params">s</span>):</span><br><span class="line">    list1 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            list1.append(i)</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span>.join(list1)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入：&quot;</span>)</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(trim(s))</span><br></pre></td></tr></table></figure>

<h4 id="字符串转列表"><a href="#字符串转列表" class="headerlink" title="字符串转列表"></a>字符串转列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;list&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.split())</span><br><span class="line">---&gt;[<span class="string">&#x27;list&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>split()中可写分隔符(默认空格)，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;a,list&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">---&gt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;list&#x27;</span>]</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>python爬虫-1</title>
    <url>/2022/04/10/python%E7%88%AC%E8%99%AB-1/</url>
    <content><![CDATA[<h3 id="Web请求过程"><a href="#Web请求过程" class="headerlink" title="Web请求过程"></a>Web请求过程</h3><ol>
<li><p>服务器渲染：在服务器那边直接把数据和html整合在一起，统一返回给浏览器<br> <img src="/2022/04/10/python%E7%88%AC%E8%99%AB-1/2022-04-10-19-36-06.png"></p>
</li>
<li><p>客户端渲染：第一次请求只有一个html骨架，第二次请求拿到数据，进行数据展示，在页面源代码中，看不到数据<br> <img src="/2022/04/10/python%E7%88%AC%E8%99%AB-1/2022-04-10-19-39-37.png"></p>
<p> 对于客户端渲染，以豆瓣喜剧电影排行榜举例，在网页按下F12，然后点击network就可看到相应数据<br> <img src="/2022/04/10/python%E7%88%AC%E8%99%AB-1/2022-04-10-19-46-42.png"><br> 同样地，在network的headers下可以查找到url，请求方式，user-agent等重要内容</p>
</li>
</ol>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议把一条消息分为三大块内容，无论是请求还是响应</p>
<p>请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求行-&gt; 请求方式（get/post） 请求url地址 协议</span><br><span class="line">请求头-&gt; 放一些服务器要使用的附加信息</span><br><span class="line"></span><br><span class="line">请求体-&gt; 一般放一些请求参数</span><br></pre></td></tr></table></figure>
<p>请求头里一些重要内容：</p>
<ol>
<li>User-Agent:请求载体的身份标识（用啥发送的请求）</li>
<li>Referer：防盗链（这次请求从哪个页面来？反爬会用到）</li>
<li>cookie：本地字符串数据信息（用户登录信息，反爬的token）</li>
</ol>
<p>响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">响应行-&gt; 协议 状态码</span><br><span class="line">响应头-&gt; 放一些客户端要使用的一些附加信息</span><br><span class="line"></span><br><span class="line">响应体-&gt; 服务器返回的真正客户端要使用的内容（HTML,json)等</span><br></pre></td></tr></table></figure>
<p>响应头中的一些重要内容：</p>
<ol>
<li>cookie：本地字符串数据信息（用户登录信息，反爬的token）</li>
<li>各种字符串（需要经验，一般是token字样，防止各种攻击和反爬）</li>
</ol>
<p>一些练手的小爬虫程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="comment">#导入requests库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#爬取搜狗搜索“周杰伦”页面</span></span><br><span class="line">url = <span class="string">&#x27;https://www.sogou.com/web?query=周杰伦&#x27;</span></span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&#x27;user-agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">resp = requests.get(url,headers=dic)<span class="comment">#headers处理反爬</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp)</span><br><span class="line"><span class="built_in">print</span>(resp.text)<span class="comment">#打印页面源代码</span></span><br><span class="line">resp.close() <span class="comment">#关掉resp，防止请求次数过多</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#爬取百度搜索“周杰伦”页面</span></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?wd=周杰伦&#x27;</span></span><br><span class="line"></span><br><span class="line">resp = requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br><span class="line">resp.close() <span class="comment">#关掉resp，防止请求次数过多</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#爬取豆瓣喜剧电影排行榜页面</span></span><br><span class="line">url = <span class="string">&#x27;https://movie.douban.com/j/chart/top_list&#x27;</span></span><br><span class="line"></span><br><span class="line">param = &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;24&quot;</span>,</span><br><span class="line">    <span class="string">&quot;interval_id&quot;</span>: <span class="string">&quot;100:90&quot;</span>,</span><br><span class="line">    <span class="string">&quot;action&quot;</span>: <span class="string">&quot;&quot;</span> ,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;limit&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dic = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url=url, params=param,headers=dic)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp.json())</span><br><span class="line">resp.close() <span class="comment">#关掉resp，防止请求次数过多</span></span><br></pre></td></tr></table></figure>
<p>需要注意的一点：发送get请求带参数的话是params，post的为data</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>栈与递归</title>
    <url>/2022/03/28/%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>首先，什么是递归？</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><ol>
<li>定义：<ul>
<li>若一个对象部分地包含它自己，或用它自己给它自己定义，则称这个对象是递归的。</li>
<li>若一个过程直接或间接地调用自己，则称这个过程是递归的过程</li>
</ul>
</li>
</ol>
<ul>
<li>举例：<br>  递归求n的阶乘  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">Fac</span><span class="params">(<span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * <span class="built_in">Fac</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>三种常常用到递归方法的情况：</p>
<ul>
<li>递归定义的数学函数，如阶乘函数，二阶斐波那契数列</li>
<li>具有递归特性的数据结构，如二叉树，广义表</li>
<li>可递归求解的问题，如迷宫问题，汉诺塔问题</li>
</ul>
</li>
<li><p>递归问题求解方法<br><img src="/2022/03/28/%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92/2022-03-28-20-41-31.png"><br><img src="/2022/03/28/%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92/2022-03-28-20-43-00.png"></p>
</li>
</ol>
<h4 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h4><p>函数递归调用遵循后调用的先返回，与栈类似。</p>
<ul>
<li>函数调用过程<br><img src="/2022/03/28/%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92/2022-03-28-20-50-06.png"></li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>算法与数据结构(2)</title>
    <url>/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</url>
    <content><![CDATA[<p>顺序表多少有点摆烂，看看书吧。</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><ol>
<li>定义：<br>  由n(n&gt;&#x3D;0)个数据元素（结点）a<del>1</del>,a<del>2</del>,a<del>3</del>,…a<del>n</del>组成的有限序列。<ul>
<li>数据元素的个数n定义为表的长度。</li>
<li>n&#x3D;0时称为空表。</li>
<li>将非空的线性表（n&gt;0）记作：(a<del>1</del>,a<del>2</del>,a<del>3</del>,…a<del>n</del>)</li>
<li>这里的数据元素a<del>i</del>（1&lt;&#x3D;i&lt;&#x3D;n)只是一个抽象的符号，其具体含义在不同情况下可以不同</li>
<li>同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系。</li>
</ul>
</li>
<li>逻辑特征：<br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-22-17-22-47.png">  </li>
<li>类型定义：<br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-22-18-42-57.png"></li>
</ol>
<h3 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h3><ul>
<li>顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。（逻辑上相邻，物理上也相邻）</li>
<li>线性表存储结构占用一片连续的存储空间。</li>
<li>在访问线性表时，可以快速计算出任何一个数据元素的存储地址。因此可以粗略认为，访问每个元素花费时间相等。是<strong>随机存取法</strong>。 </li>
<li>线性表基本操作：<br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-00-41-35.png"></li>
<li>顺序表优缺点：<ol>
<li>优点：<ul>
<li>存储密度大</li>
<li>可以随机存取表中任一元素</li>
</ul>
</li>
<li>缺点：<ul>
<li>在插入、删除某一元素时，需要移动大量元素   </li>
<li>浪费存储空间</li>
<li>属于静态存储形式，数据元素的个数不能自由扩充</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h3><ul>
<li><p>链式存储定义：用一组物理位置任意的存储单元来存放线性表的数据元素</p>
</li>
<li><p>这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。</p>
</li>
<li><p>链表特点：</p>
<ul>
<li>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。</li>
<li>访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等。是<strong>顺序存取法</strong>。</li>
</ul>
</li>
<li><p>链式存储结构术语：</p>
<ul>
<li><p>结点：数据元素的存储映像。由数据域和指针域组成。</p>
<ul>
<li>各结点由两个域组成：<ul>
<li>数据域：存储元素数值数据</li>
<li>指针域：存储后继结点的存储位置</li>
</ul>
</li>
</ul>
</li>
<li><p>链表：n个结点由指针链组成一个链表</p>
<ul>
<li>单链表、双链表和循环链表：<ul>
<li>结点只有一个指针域的链表，称为<strong>单链表</strong>或线性链表<br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-15-53-33.png"></li>
<li>结点有两个指针域的链表，称为<strong>双链表</strong><br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-15-54-32.png"> </li>
<li>首尾相接的链表称为<strong>循环链表</strong><br>  <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-15-55-37.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>头指针、头结点和首元结点：</p>
<ul>
<li>头指针：指向链表中第一个结点的指针</li>
<li>首元结点：链表中存储第一个数据元素的结点</li>
<li>头结点：在链表的首元结点之前附设的一个结点<br> <img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-15-58-21.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>关于链表的一些讨论：</p>
<ul>
<li>如何表示空表？<ul>
<li>无头结点时，头指针为空时表示空表</li>
<li>有头结点时，当头结点的指针域为空时表示空表</li>
</ul>
</li>
<li>设置头结点有什么好处？<ol>
<li>便于首元结点的处理<ul>
<li>首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理</li>
</ul>
</li>
<li>便于空表和非空表的统一处理<ul>
<li>无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。</li>
</ul>
</li>
</ol>
</li>
<li>头结点的数据域中装的是什么？<ul>
<li>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。</li>
</ul>
</li>
</ul>
</li>
<li><p>链式存储结构优缺点：</p>
<ul>
<li>优点：<ol>
<li>结点空间可以动态申请和释放</li>
<li>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素</li>
</ol>
</li>
<li>缺点：<ol>
<li>存储密度[^1]小，每个节点的指针需额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间比重显得很大。<br>[^1]: 存储密度是指结点数据本身所占的存储量和整个结点结构中所占存储量之比，即：<br>存储密度 &#x3D; 结点数据本身占用空间&#x2F;节点占用的空间总量<br>一般，存储密度越大，存储空间利用率就越高。顺序表存储密度为1，而链表存储密度小于1.</li>
<li>链式存储结构是非随机存取结构。对任一结点的操作都要从头指针依指针链查找到该结点，这增加了算法的复杂度。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-16-12-17.png"></p>
<ul>
<li>单链表由头指针唯一确定，因此单链表可以用头指针的名字来命名。若头指针名是L，则把链表称为表L。</li>
</ul>
<p><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-16-16-06.png"></p>
<p>这里 next 包含了下一个结点</p>
<ul>
<li><p>通常，<br>   定义链表L：LinkList L；<br>   定义结点指针p：LNode *p；<br>   虽然说LinkList和LNode是等价的。</p>
</li>
<li><p>为了统一链表的操作，通常这样定义链表：</p>
</li>
</ul>
<p><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-16-22-34.png"></p>
<center>存储学生学号姓名成绩的单链表节点类型定义</center>

<ul>
<li>单链表基本操作：<br><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-23-20-57-10.png"><br>（操作的算法还是自己多动手去吧。）</li>
</ul>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ul>
<li><p>是一种头尾相接的链表，即表中最后一个结点的指针域指向头结点，整个链表形成一个环。<br><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-24-21-13-57.png"></p>
</li>
<li><p>优点：从任何一个结点出发均可找到表中其他结点</p>
</li>
<li><p>循环链表的空表<br><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-24-18-03-33.png"> </p>
</li>
<li><p>循环链表中涉及遍历操作时，终止条件时判断是否等于头指针</p>
</li>
<li><p>表的操作常常在表的首尾位置上进行。循环链表一般带尾指针（方便）</p>
</li>
</ul>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ul>
<li><p>在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了有两个方向不同的链，故称为双链表。<br><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-24-21-17-34.png"><br><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-24-21-18-11.png"></p>
</li>
<li><p>双向链表的对称性（设指针p指向某一结点）：<br>p-&gt;prior-&gt;next &#x3D; p &#x3D; p-&gt;next-&gt;prior</p>
<h5 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h5></li>
<li><p>让双向链表的头结点的前驱指针指向链表的最后一个结点</p>
</li>
<li><p>让最后一个结点的后继指针指向头结点。<br><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-24-21-19-35.png"></p>
</li>
</ul>
<h4 id="单链表、循环链表和双向链表比较"><a href="#单链表、循环链表和双向链表比较" class="headerlink" title="单链表、循环链表和双向链表比较"></a>单链表、循环链表和双向链表比较</h4><p><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-24-21-40-35.png"></p>
<h3 id="链表和顺序表比较"><a href="#链表和顺序表比较" class="headerlink" title="链表和顺序表比较"></a>链表和顺序表比较</h3><p><img src="/2022/03/22/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/2022-03-24-21-55-10.png"></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>算法与数据结构(3)</title>
    <url>/2022/03/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/</url>
    <content><![CDATA[<p>栈和队列是限定插入和删除只能在表的“端点”进行的线性表。栈和队列是线性表的子集</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol>
<li><p>定义：栈是一个特殊的线性表，是限定仅在一端（通常是表尾）进行插入和删除操作的线性表。<br>又称为<strong>后进先出</strong>的线性表，简称LIFO（Last In First Out）结构</p>
</li>
<li><p>逻辑结构：<br> 与线性表相同，同为一对一结构</p>
</li>
<li><p>存储结构：<br> 用顺序栈或链栈存储均可，以顺序栈更为常见</p>
</li>
<li><p>运算规则：<br> 只能在栈顶运算，访问结点时依照后进先出原则</p>
</li>
<li><p>实现方式：<br> 关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同</p>
</li>
</ol>
<ul>
<li><p>栈与一般线性表只在运算规则有所不同</p>
</li>
<li><p>栈的示意图<br>表尾（a<del>n</del>端）称为栈顶Top，表头（a<del>1</del>端）称为栈底Base<br><img src="/2022/03/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/2022-03-27-22-30-06.png"></p>
</li>
<li><p>插入元素到栈顶的操作叫入栈，从栈顶删除最后一个元素的操作叫出栈</p>
<ul>
<li>思考：<br>有三个元素a，b，c，入栈顺序是a，b，c，则他们的出栈顺序有几种？<ul>
<li>5种</li>
</ul>
<ol>
<li>cba abc全部入栈然后出栈</li>
<li>abc a入栈a出栈，b入栈b出栈，c入栈，c出栈</li>
<li>acb a入栈a出栈，bc入栈，cb出栈</li>
<li>bac ab入栈，ba出栈，c入栈c出栈 </li>
<li>bca ab入栈，b出栈，c入栈c出栈，a出栈<br>不会出现cab的可能</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><ol>
<li><p>存储方式：<br>同一般线性表的顺序存储结构完全相同，利用一组地址连续的存储单元一次存放自栈底到栈顶的数据元素。栈底一般在低地址端。</p>
<ul>
<li>附设top指针，指示栈顶元素在顺序栈中的位置，为了方便操作，top指示栈顶元素之上的下标地址</li>
<li>另设base指针，指示栈底元素在顺序栈中的位置</li>
<li>用stacksize表示栈可使用的最大容量</li>
<li>空栈：top&#x3D;&#x3D;base 是栈空标志</li>
<li>栈满：top-base&#x3D;&#x3D;stacksize<ul>
<li>栈满时的处理方法：<ol>
<li>报错，返回操作系统</li>
<li>分配更大的空间，作为栈的存储空间，将原栈的内容移入新栈</li>
</ol>
</li>
</ul>
</li>
<li>溢出：<br>  1.上溢（overflow）：栈已满，又要压入元素。<br>  上溢是一种错误，使问题的处理无法进行。<br>  2.下溢（underflow）：栈已空，还要弹出元素<br>  下溢一般认为是一种结束条件，即问题处理结束</li>
</ul>
</li>
<li><p>顺序栈数据类型定义：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemType *base;<span class="comment">//栈底指针</span></span><br><span class="line">    SElemType *top;<span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="type">int</span> stacksize;<span class="comment">//栈可用最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<ul>
<li>栈中元素个数：top-base<ul>
<li>这里是两个指针相减，得到的其实是两个元素之间相差几个元素</li>
</ul>
</li>
</ul>
</li>
<li><p>顺序栈基本操作：</p>
<ol>
<li>顺序栈初始化 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base = <span class="keyword">new</span> SElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span> (!S.base) <span class="built_in">exit</span> (OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>判断顺序栈是否为空 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>求顺序栈长度 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>清空顺序栈 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Staus <span class="title">ClearStack</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base) S.top = S.base;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>销毁顺序栈 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base)&#123;</span><br><span class="line">        <span class="keyword">delete</span> S.base;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        S.base = S.top = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>顺序栈的入栈 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base == S.stacksize)<span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *S.top++ = e;<span class="comment">//*S.top=e; S.top++;</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>顺序栈的出栈  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Sqtack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)<span class="comment">//等价于if(StackEmpty(S))</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--S.top;<span class="comment">//--S.top; e = *S.top;</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><ol>
<li><p>定义：链栈是运算受限的单链表，只能在链表头部进行操作。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span>&#123;</span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StackNode</span> *next;</span><br><span class="line">&#125;StackNode, *LinkStack;</span><br><span class="line">LinkStack S;</span><br></pre></td></tr></table></figure>

<p> <img src="/2022/03/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/2022-03-28-20-16-27.png"> 链栈中指针的方向指向前驱元素。</p>
<ul>
<li>链栈的头指针就是栈顶</li>
<li>不需要头结点</li>
<li>基本不存在栈满的情况</li>
<li>空栈相当于头指针指向空</li>
<li>插入和删除仅在栈顶处执行</li>
</ul>
</li>
<li><p>链栈基本操作：</p>
<ol>
<li>链栈的初始化 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>判断链栈是否为空 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>链栈的入栈 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> StackNode;</span><br><span class="line">    p -&gt; data = e;</span><br><span class="line">    p -&gt; next = S;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>链栈的出栈 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">        e = S -&gt; data;</span><br><span class="line">        p = S;</span><br><span class="line">        S = S  -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    ```     </span><br><span class="line"><span class="number">5.</span> 取栈顶元素</span><br><span class="line">    ```c++</span><br><span class="line">    <span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> S -&gt; data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h3><p>移步 <a href="https://inengyang.github.io/2022/03/28/%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92/">栈与递归</a></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ol>
<li><p>定义：<br> 队列是一种先进先出（FIFO）的线性表。在表尾（队尾）插入，在表头（队头）删除。</p>
</li>
<li><p>逻辑结构：<br> 与线性表相同，同为一对一结构</p>
</li>
<li><p>存储结构：<br> 顺序队或链队，以循环顺序队列更为常见</p>
</li>
<li><p>运算规则：<br> 只能在队首和队尾运算，访问结点时依照先进先出原则</p>
</li>
<li><p>实现方式：<br> 关键是掌握入队和出队操作，具体实现依顺序队或链队的不同而不同</p>
</li>
</ol>
<ul>
<li>队列的示意图<br><img src="/2022/03/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/2022-03-27-22-48-56.png"></li>
</ul>
<h3 id="队列的顺序表示————用一维数组base-MAXQSIZE"><a href="#队列的顺序表示————用一维数组base-MAXQSIZE" class="headerlink" title="队列的顺序表示————用一维数组base[MAXQSIZE]"></a>队列的顺序表示————用一维数组base[MAXQSIZE]</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100 <span class="comment">//最大队列长度</span></span></span><br><span class="line">Typedef <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="type">int</span> front;<span class="comment">//头指针</span></span><br><span class="line">    <span class="type">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>初始化</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">front = rear = 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>入队</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base[rear] = x;</span><br><span class="line">rear++;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出队</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = base[front]; front++;</span><br></pre></td></tr></table></figure>
</li>
<li><p>空队标志</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">front == rear;</span><br></pre></td></tr></table></figure>
</li>
<li><p>溢出<br>  当rear &#x3D; MAXQSIZE 时，不能再入队，发生溢出</p>
<ul>
<li><p>真溢出<br>  若front &#x3D; 0<br>  rear &#x3D; MAXQSIZE 时，再入队————真溢出<br>  <img src="/2022/03/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/2022-04-03-15-28-46.png"></p>
</li>
<li><p>假溢出<br>  front !&#x3D; 0<br>  rear &#x3D; MAXQSIZE 时，再入队————假溢出<br>  <img src="/2022/03/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/2022-04-03-15-29-18.png"></p>
</li>
<li><p>解决假溢出——引入循环队列<br>  将base[0]接在base[MAXQSIZE-1]之后，若rear +1 &#x3D;&#x3D;MAXQSIZE，则令rear&#x3D;0;——就是想象把队列变成一个圈。<br>  <img src="/2022/03/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/2022-04-03-15-27-43.png"><br>  实现方法：对MAXQSIZE模运算<br>  base[n] 对 MAXQSIZE取模都是n，只有MAXQSIZE会等于0，就能做到base[0]接在base[MAXQSIZE-1]之后</p>
<ul>
<li>插入元素：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q.base[Q.rear] = x;</span><br><span class="line">Q.rear = (Q.rear+1) % MAXQSIZE</span><br></pre></td></tr></table></figure></li>
<li>删除元素：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = Q.base[Q.front]</span><br><span class="line">Q.front = (Q.front+1) % MAXQSIZE</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>顺序循环队列中的队空队满</p>
<p>  顺序循环队列中队空和队满时都是front &#x3D;&#x3D; rear</p>
<ul>
<li><p>解决方案：</p>
<ol>
<li>另外设一个标志区别队空和队满，比如设置一个数组存放对应元素？</li>
<li>另设一个变量，记录元素个数</li>
<li>少用一个元素空间<br>  说实话觉得第二种好。。</li>
</ol>
</li>
<li><p>循环队列解决队满时判断方法——少用一个元素空间<br>  <img src="/2022/03/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/2022-04-03-15-26-52.png"><br>  此时队满：队尾指针+1，就与队头指针重合<br>  队满标志：(rear+1) % MAXQSIZE &#x3D; front</p>
</li>
</ul>
</li>
</ul>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><ol>
<li><p>类型定义</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100 <span class="comment">//最大队列长度</span></span></span><br><span class="line">Typedef <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="type">int</span> front;<span class="comment">//头指针,若队列不空，指向队列头元素</span></span><br><span class="line">    <span class="type">int</span> rear;<span class="comment">//尾指针，若队列不空，指向队列尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>队列初始化</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.base = <span class="keyword">new</span> QElemType[MAXQSIZE]</span><br><span class="line">    <span class="keyword">if</span>(!Q.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求队列长度</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里是考虑到了<br> <img src="/2022/03/27/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/2022-04-03-15-40-09.png"><br> 第二种队列的情况 </p>
</li>
<li><p>循环队列入队</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXQSIZE==Q.front) <span class="keyword">return</span> ERROR<span class="comment">//队满</span></span><br><span class="line">    Q.base[Q.rear]=e;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>循环队列出队</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;<span class="comment">//队列为空</span></span><br><span class="line">        e = Q.base[Q.front];</span><br><span class="line">        Q.front = (Q.front + <span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    ```  </span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 取队头元素</span><br><span class="line">    ```c++</span><br><span class="line">    <span class="function">SElemType <span class="title">GetHead</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Q.front != Q.rear) <span class="comment">//队列不为空</span></span><br><span class="line">            <span class="keyword">return</span> Q.base[Q.front];<span class="comment">//返回队头指针元素，队头指针不变</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h3><p>   若用户无法估计所用队列的长度，宜用链队</p>
<ol>
<li>链队的类型定义<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Qnode</span></span><br><span class="line">    &#123;</span><br><span class="line">        QElemType data;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Qnode</span> *next;</span><br><span class="line">    &#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">    &#123;</span><br><span class="line">        QueuePtr front;<span class="comment">//头指针</span></span><br><span class="line">        QueuePtr rear;<span class="comment">//尾指针</span></span><br><span class="line">    &#125;LinkQueue;</span><br><span class="line">  ```      </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 链队列的初始化</span><br><span class="line">    ```c++</span><br><span class="line">    <span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Q.front = Q.rear = <span class="keyword">new</span> QNode</span><br><span class="line">        <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW)</span><br><span class="line">        Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>3. 销毁链队列

    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestoryQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Q.front)</span><br><span class="line">    &#123;</span><br><span class="line">        p=Q.front-&gt;;<span class="keyword">delete</span> Q.front;Q.front=p;</span><br><span class="line">    &#125;<span class="comment">//或者把p改成Q.rear</span></span><br><span class="line">    <span class="comment">//Q.rear=Q.front-&gt;;delete Q.front;Q.front=Q.rear;</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

4. 入队

    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> QNode</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e;p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

5. 出队

    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p=Q.front-&gt;next; e=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p) Q.rear==Q.front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

6. 求队头元素
    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=Q.front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>算法与数据结构-4</title>
    <url>/2022/04/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/</url>
    <content><![CDATA[<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><ol>
<li><p>定义：零个或多个任意字符组成的有限序列</p>
<p> <img src="/2022/04/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/2022-04-04-15-14-20.png"></p>
</li>
</ol>
<ul>
<li>子串：一个串中任意个连续字符组成的子序列（含空串）称为该串的子串<br> 真子串是指不包含自身的所有子串。</li>
<li>主串：包含子串的串相应地称为主串</li>
<li>字符位置：字符在序列中的序号为该字符在串中的位置</li>
<li>空格串：由一个或多个空格组成的串，与空串不同。</li>
<li>串相等：当且仅当两个串的长度相等且各个对应位置上的字符都相同时，这两个串才是相等的。所有空串都是相等的。</li>
</ul>
<ol start="2">
<li>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构</li>
</ol>
<h3 id="顺序串"><a href="#顺序串" class="headerlink" title="顺序串"></a>顺序串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch[MAXLEN+<span class="number">1</span>];<span class="comment">//存储串的一维数组，+1可以使下标为0-256，应该会方便研究一些算法。</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
<ul>
<li>ps：研究串的某些算法时，通常从数组的一号位置开始存储，会方便一些。<br>顺序串用的比较多，因为对串进行插入和删除比较少，在查找和匹配时用顺序串比较方便。</li>
</ul>
<h3 id="链串"><a href="#链串" class="headerlink" title="链串"></a>链串</h3><p>链串可以将多个字符放在一个结点中，克服存储密度低的缺点。<br><img src="/2022/04/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/2022-04-04-15-31-45.png"><br>被称为，块链结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Chunk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Chunk</span> *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    Chunk *head,*tail;<span class="comment">//串的头指针和尾指针</span></span><br><span class="line">    <span class="type">int</span> curlen;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure>

<h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><ol>
<li>算法目的：确定主串中所含子串（模式串）第一次出现的位置（定位）</li>
<li>算法应用：<ul>
<li>搜索引擎，拼写检查，语言翻译，数据压缩</li>
</ul>
</li>
<li>算法种类：<ul>
<li>BF算法（暴力破解），时间效率差一些</li>
<li>KMP算法，速度快一些</li>
</ul>
</li>
</ol>
<h4 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h4><p>亦称简单匹配算法，采用穷举法的思路。</p>
<ul>
<li>算法思路：<br>  Index(S,T,pos)<br>  主串S：a a a a b c d<br>  模式串T: a b c<br>  将主串的第pos个字符和模式串的第一个字符比较，<ul>
<li>若相等，继续逐个比较后续字符；</li>
<li>若不等，从主串pos的下一个字符起，重新与模式串的第一个字符比较<ul>
<li>直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的第一个子序列第一个字符的序号，即匹配成功。</li>
<li>否则，匹配失败，返回值0</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> Index <span class="title">BF</span><span class="params">(SString S, SString T,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;= T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i]==t.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;=T.length) <span class="keyword">return</span> i-T.length<span class="comment">//返回匹配的第一个字符下标</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>算法时间复杂度：<br>  最好情况：一次匹配即成功，有m个字符，时间复杂度就为O(m)<br>  最差情况：<ul>
<li>若n为主串长度，m为子串长度，主串前面n-m个位置都部分匹配到了子串的最后一位，即这n-m位各比较了m次</li>
<li>最后m位也各比较了一次</li>
<li>所以总次数为(n-m)*m+m &#x3D; (n-m+1)*m</li>
<li>若m &lt;&lt; n,则算法时间复杂度为O(n<em>m),平均为$n</em>m\over2$</li>
</ul>
</li>
</ul>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>大概就是利用部分匹配结果中与模式串相同的字符，从而加快模式串的滑动速度<br><img src="/2022/04/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/2022-04-04-19-58-40.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> Index <span class="title">KMP</span><span class="params">(SString S, SString T,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;= T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || s.ch[i]==t.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;=T.length) <span class="keyword">return</span> i-T.length<span class="comment">//返回匹配的第一个字符下标</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(SString T,<span class="type">int</span> &amp;next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i=<span class="number">1</span>;next[<span class="number">1</span>]=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || T.ch[i]==T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义next[j]:<br><img src="/2022/04/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/2022-04-04-20-04-45.png"><br><img src="/2022/04/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/2022-04-04-20-05-37.png"></p>
<p>  比如说，j&#x3D;6的b字符，从6b的前一个字符（5a）开始与第一个字符（1a）比较，发现匹配成功，此时有k-1个元素相同，所以k&#x3D;2；再从6b的前两个字符（4a5a）与1a2b比较，匹配失败，之后以此类推。</p>
</li>
<li><p>next函数改进(好难。。整不明白)</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nextval</span><span class="params">(SString T,<span class="type">int</span> &amp;nextval[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i=<span class="number">1</span>;nextval[<span class="number">1</span>]=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || T.ch[i]==T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i] != T.ch[j]) nextval[i]=j;</span><br><span class="line">            <span class="keyword">else</span> nextval[i] = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>算法与数据结构(1)</title>
    <url>/2022/03/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>写在前面：因为之前就学了数据结构的内容，所以这篇数据结构就偷懒跳过不写了</p>
<h1 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h1><ol>
<li><p>定义：<br>对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。<br>简而言之，<strong>算法就是解决问题的方法和步骤</strong></p>
</li>
<li><p>算法特性：</p>
<ol>
<li>有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。</li>
<li>确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。 </li>
<li>可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</li>
<li>输入：一个算法有0个或多个输入。</li>
<li>输出：一个算法有一个或多个输出。</li>
</ol>
</li>
<li><p>算法设计要求：</p>
<ol>
<li>正确性：程序对于精心选择的，典型、苛刻且带有刁难性的几组输入数据能够得出满足要求的结果。</li>
<li>可读性</li>
<li>健壮性：<ol>
<li>指输入非法数据时，算法恰当的做出反应或进行相应处理而不是产生奇怪的输出结果。</li>
<li>处理出错的方法，不应是中断程序的执行，而是返回一个表示错误或者错误性质的值，以便在更高的抽象层次上进行处理。</li>
</ol>
</li>
<li>高效性</li>
</ol>
</li>
<li><p>算法的效率：</p>
<ul>
<li>算法有时间效率和空间效率</li>
</ul>
<ol>
<li>时间效率：<br> 时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量<ul>
<li>度量方法：<ol>
<li>事后统计：<br>  将算法实现，测算时间和空间开销。</li>
<li>事前分析：<br>  对算法所消耗资源的一种估算方法。</li>
</ol>
<ul>
<li>多采用事前分析，事后统计的方法，编写程序耗费时间和精力，结果依赖于计算机软硬件因素。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>算法运行时间 &#x3D; 一个简单操作所需时间 $\times$ 简单操作次数<br>        &#x3D; $\sum$ 每条语句执行次数（每条语句频度） $\times$ 该语句执行一次所需时间<ul>
<li>假设执行每条语句所需时间均为单位时间，此时对算法的运行时间的讨论就可以转化为讨论该算法中的所有语句的执行次数，即频度和。</li>
<li>即算法耗费时间为算法每条语句的频度之和，表示为T(n)。</li>
<li>额外的，一般只考虑算法中的基本操作执行的次数，且仅比较数量级</li>
</ul>
</li>
<li>算法时间复杂度：<ul>
<li>算法中基本语句（执行最多的语句）重复执行的次数是问题规模n的某个函数f(n)，算法时间的量度记作T(n) &#x3D; O(f(n))</li>
<li>它表示随着n增大，算法执行的时间的增长率和f(n)的增长率相同，称为渐近时间复杂度。</li>
<li>对于复杂的算法，可以将它分为几个容易估算的部分，然后利用加法法则和乘法法则计算时间复杂度<ol>
<li>加法法则：<br> T(n) &#x3D; T1(n) + T2(n) &#x3D; O(f(n)) + O(g(n)) &#x3D;O(max(f(n),g(n)))</li>
<li>乘法法则：<br> T(n) &#x3D; T1(n) $\times$ T2(n) &#x3D; O(f(n)) $\times$ O(g(n)) &#x3D; O(f(n) $\times$ g(n))</li>
</ol>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>算法空间复杂度：<br> S(n) &#x3D; O(f(n))<ul>
<li>算法要占据的空间：<ol>
<li>算法本身要占据的空间，输入&#x2F;输出，指令，常数，变量等</li>
<li>算法要使用的辅助空间</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>计算时间复杂度的练习</title>
    <url>/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/2022-03-21-23-07-37.png"></p>
<ol>
<li>很容易看出语句频度最大的语句是<code>for(int j = 0;j &lt; n;j++)</code></li>
<li>其执行次数为n(n+1),即n^2^<ul>
<li>对于循环来说直接找嵌套最深的语句也可以，即<code>y++;</code>,执行次数为n^2^</li>
</ul>
</li>
<li>T(n)&#x3D;O(n^2^)</li>
</ol>
<p>####例1</p>
<p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/2022-03-21-23-17-41.png" title="例1"></p>
<ol>
<li>嵌套最深的语句为<code>sum[i] += x[i][j];</code> </li>
<li>执行次数为 m $\times$ n 次</li>
<li>T(n)&#x3D;O(m $\times$ n)</li>
</ol>
<p>####虽然但是这是例2<br><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/2022-03-21-23-21-45.png"></p>
<ol>
<li>嵌套最深语句为<code>c[i][j] = c[i][j] + a[i][k] * b[k][j];</code></li>
<li>执行次数为n^3^</li>
<li>T(n)&#x3D;O(n^3^)</li>
</ol>
<p>####例3</p>
<p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/2022-03-21-23-26-30.png"></p>
<ol>
<li>可以看出嵌套最深语句是<code>x=x+1</code> </li>
<li>但是计算时间复杂度时，需要用级数求和法</li>
<li>语句频度 &#x3D; $\sum_{i&#x3D;1}^n$$\sum_{j&#x3D;1}^i$$\sum_{k&#x3D;1}^j$1 &#x3D; $\sum_{i&#x3D;1}^n$$\sum_{j&#x3D;1}^i$j &#x3D; $\sum_{i&#x3D;1}^n$$i(i+1) \over 2$ &#x3D;$1\over2$($\sum_{i&#x3D;1}^n$i^2^ + $\sum_{i&#x3D;1}^n$i) &#x3D;$1\over2$($n(n+1)(2n+1)\over 6$ + $n(n+1)\over2$) &#x3D; $n(n+1)(n+2)\over 6$</li>
<li>f(n) &#x3D; n^3^</li>
<li>T(n)&#x3D;O(n^3^)<ul>
<li>（计算语句频度最后一个求和不会。。）</li>
</ul>
</li>
</ol>
<p>####例4</p>
<p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%BB%83%E4%B9%A0/2022-03-22-00-05-42.png"></p>
<ol>
<li><p>执行次数最多为<code>i=i*2;</code></p>
<ul>
<li>关键要找出执行次数x与n的关系，并表示成n的函数</li>
<li>执行1次，i&#x3D;1*2&#x3D;2；</li>
<li>执行2次，i&#x3D;2*2&#x3D;2^2^；</li>
<li>执行3次，i&#x3D;2^2^*2&#x3D;2^3^；</li>
<li>…</li>
<li>执行x次，i&#x3D;2^x^</li>
</ul>
</li>
<li><p>设语句<code>i=i*2</code>执行x次,由循环条件，</p>
<p> i&lt;&#x3D;n,   $\because$ 2^x^&lt; n , $\therefore$ x&lt;&#x3D;${log_2{n}}$</p>
</li>
<li><p>所以f(n)&#x3D;${log_2{n}}$</p>
</li>
<li><p>T(n)&#x3D;O(${log_2{n}}$)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
</search>
